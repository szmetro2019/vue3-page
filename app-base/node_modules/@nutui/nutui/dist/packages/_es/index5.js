/*!
* @nutui/nutui v3.3.8 Mon Jun 12 2023 11:24:18 GMT+0800 (中国标准时间)
* (c) 2022 @jdf2e.
* Released under the MIT License.
*/
import { ref, computed, reactive, watch, toRefs, openBlock, createElementBlock, normalizeClass, createElementVNode, toDisplayString, createCommentVNode, renderSlot, Fragment, renderList, normalizeStyle, createTextVNode } from "vue";
import { c as createComponent } from "./component.js";
import { r as requestAniFrame } from "./raf.js";
import { u as useExpose } from "./index3.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper.js";
const Utils = {
  isLeapYear: function(y) {
    return y % 4 == 0 && y % 100 != 0 || y % 400 == 0;
  },
  getWhatDay: function(year, month, day) {
    const date = new Date(year + "/" + month + "/" + day);
    const index = date.getDay();
    const dayNames = [
      "\u661F\u671F\u65E5",
      "\u661F\u671F\u4E00",
      "\u661F\u671F\u4E8C",
      "\u661F\u671F\u4E09",
      "\u661F\u671F\u56DB",
      "\u661F\u671F\u4E94",
      "\u661F\u671F\u516D"
    ];
    return dayNames[index];
  },
  getMonthPreDay: function(year, month) {
    const date = new Date(year + "/" + month + "/01");
    let day = date.getDay();
    if (day == 0) {
      day = 7;
    }
    return day;
  },
  getMonthDays: function(year, month) {
    if (/^0/.test(month)) {
      month = month.split("")[1];
    }
    return [
      0,
      31,
      this.isLeapYear(Number(year)) ? 29 : 28,
      31,
      30,
      31,
      30,
      31,
      31,
      30,
      31,
      30,
      31
    ][month];
  },
  getNumTwoBit: function(n) {
    n = Number(n);
    return (n > 9 ? "" : "0") + n;
  },
  date2Str: function(date, split) {
    split = split || "-";
    const y = date.getFullYear();
    const m = this.getNumTwoBit(date.getMonth() + 1);
    const d = this.getNumTwoBit(date.getDate());
    return [y, m, d].join(split);
  },
  getDay: function(i) {
    i = i || 0;
    let date = new Date();
    const diff = i * (1e3 * 60 * 60 * 24);
    date = new Date(date.getTime() + diff);
    return this.date2Str(date);
  },
  compareDate: function(date1, date2) {
    const startTime = new Date(date1.replace("-", "/").replace("-", "/"));
    const endTime = new Date(date2.replace("-", "/").replace("-", "/"));
    if (startTime >= endTime) {
      return false;
    }
    return true;
  },
  isEqual: function(date1, date2) {
    const startTime = new Date(date1).getTime();
    const endTime = new Date(date2).getTime();
    if (startTime == endTime) {
      return true;
    }
    return false;
  }
};
const { create, translate } = createComponent("calendar-item");
const _sfc_main = create({
  props: {
    type: {
      type: String,
      default: "one"
    },
    isAutoBackFill: {
      type: Boolean,
      default: false
    },
    toDateAnimation: {
      type: Boolean,
      default: true
    },
    poppable: {
      type: Boolean,
      default: true
    },
    showTitle: {
      type: Boolean,
      default: true
    },
    showSubTitle: {
      type: Boolean,
      default: true
    },
    showToday: {
      type: Boolean,
      default: true
    },
    title: {
      type: String,
      default: ""
    },
    confirmText: {
      type: String,
      default: ""
    },
    startText: {
      type: String,
      default: ""
    },
    endText: {
      type: String,
      default: ""
    },
    defaultValue: {
      type: [String, Array],
      default: ""
    },
    startDate: {
      type: String,
      default: Utils.getDay(0)
    },
    endDate: {
      type: String,
      default: Utils.getDay(365)
    },
    firstDayOfWeek: {
      type: Number,
      default: 0
    }
  },
  emits: ["choose", "update", "close", "select"],
  setup(props, { emit, slots }) {
    const weekdays = translate("weekdays");
    const weeks = ref([...weekdays.slice(props.firstDayOfWeek, 7), ...weekdays.slice(0, props.firstDayOfWeek)]);
    const months = ref(null);
    const monthsPanel = ref(null);
    const weeksPanel = ref(null);
    const viewArea = ref(null);
    const viewHeight = ref(0);
    const compConthsData = computed(() => {
      return state.monthsData.slice(state.defaultRange[0], state.defaultRange[1]);
    });
    const showTopBtn = computed(() => {
      return slots.btn;
    });
    const topInfo = computed(() => {
      return slots.topInfo;
    });
    const bottomInfo = computed(() => {
      return slots.bottomInfo;
    });
    const state = reactive({
      yearMonthTitle: "",
      defaultRange: [],
      currDate: "",
      propStartDate: "",
      propEndDate: "",
      unLoadPrev: false,
      touchParams: {
        startY: 0,
        endY: 0,
        startTime: 0,
        endTime: 0,
        lastY: 0,
        lastTime: 0
      },
      transformY: 0,
      translateY: 0,
      scrollDistance: 0,
      defaultData: [],
      chooseData: [],
      monthsData: [],
      dayPrefix: "calendar-month-day",
      startData: "",
      endData: "",
      isRange: props.type === "range",
      timer: 0,
      currentIndex: 0,
      avgHeight: 0,
      monthsNum: 0
    });
    const splitDate = (date) => {
      return date.split("-");
    };
    const isStart = (currDate) => {
      return Utils.isEqual(state.currDate[0], currDate);
    };
    const isEnd = (currDate) => {
      return Utils.isEqual(state.currDate[1], currDate);
    };
    const isMultiple = (currDate) => {
      if (state.currDate.length > 0) {
        return state.currDate.some((item) => {
          return Utils.isEqual(item, currDate);
        });
      } else {
        return false;
      }
    };
    const getCurrDate = (day, month) => {
      return month.curData[0] + "-" + month.curData[1] + "-" + Utils.getNumTwoBit(+day.day);
    };
    const getClass = (day, month) => {
      const currDate = getCurrDate(day, month);
      const { type } = props;
      if (day.type == "curr") {
        if (Utils.isEqual(state.currDate, currDate) || type == "range" && (isStart(currDate) || isEnd(currDate)) || type == "multiple" && isMultiple(currDate)) {
          return `${state.dayPrefix}-active`;
        } else if (state.propStartDate && Utils.compareDate(currDate, state.propStartDate) || state.propEndDate && Utils.compareDate(state.propEndDate, currDate)) {
          return `${state.dayPrefix}-disabled`;
        } else if (type == "range" && Array.isArray(state.currDate) && Object.values(state.currDate).length == 2 && Utils.compareDate(state.currDate[0], currDate) && Utils.compareDate(currDate, state.currDate[1])) {
          return `${state.dayPrefix}-choose`;
        } else {
          return null;
        }
      } else {
        return `${state.dayPrefix}-disabled`;
      }
    };
    const confirm = () => {
      const { type } = props;
      if (type == "range" && state.chooseData.length == 2 || type != "range") {
        let chooseData = state.chooseData.slice(0);
        emit("choose", chooseData);
        if (props.poppable) {
          emit("update");
        }
      }
    };
    const chooseDay = (day, month, isFirst) => {
      if (getClass(day, month) != `${state.dayPrefix}-disabled`) {
        const { type } = props;
        let days = [...month.curData];
        days[2] = typeof day.day == "number" ? Utils.getNumTwoBit(day.day) : day.day;
        days[3] = `${days[0]}-${days[1]}-${days[2]}`;
        days[4] = Utils.getWhatDay(+days[0], +days[1], +days[2]);
        if (type == "multiple") {
          if (state.currDate.length > 0) {
            let hasIndex = void 0;
            state.currDate.forEach((item, index) => {
              if (item == days[3]) {
                hasIndex = index;
              }
            });
            if (isFirst) {
              state.chooseData.push([...days]);
            } else {
              if (hasIndex !== void 0) {
                state.currDate.splice(hasIndex, 1);
                state.chooseData.splice(hasIndex, 1);
              } else {
                state.currDate.push(days[3]);
                state.chooseData.push([...days]);
              }
            }
          } else {
            state.currDate = [days[3]];
            state.chooseData = [[...days]];
          }
        } else if (type == "range") {
          let curDataLength = Object.values(state.currDate).length;
          if (curDataLength == 2 || curDataLength == 0) {
            state.currDate = [days[3]];
          } else {
            if (Utils.compareDate(state.currDate[0], days[3])) {
              Array.isArray(state.currDate) && state.currDate.push(days[3]);
            } else {
              Array.isArray(state.currDate) && state.currDate.unshift(days[3]);
            }
          }
          if (state.chooseData.length == 2 || !state.chooseData.length) {
            state.chooseData = [[...days]];
          } else {
            if (Utils.compareDate(state.chooseData[0][3], days[3])) {
              state.chooseData = [...state.chooseData, [...days]];
            } else {
              state.chooseData = [[...days], ...state.chooseData];
            }
          }
        } else {
          state.currDate = days[3];
          state.chooseData = [...days];
        }
        if (!isFirst) {
          emit("select", state.chooseData);
          if (props.isAutoBackFill || !props.poppable) {
            confirm();
          }
        }
      }
    };
    const getCurrData = (type) => {
      const monthData = type == "prev" ? state.monthsData[0] : state.monthsData[state.monthsData.length - 1];
      let year = parseInt(monthData.curData[0]);
      let month = parseInt(monthData.curData[1].toString().replace(/^0/, ""));
      switch (type) {
        case "prev":
          month == 1 && (year -= 1);
          month = month == 1 ? 12 : --month;
          break;
        case "next":
          month == 12 && (year += 1);
          month = month == 12 ? 1 : ++month;
          break;
      }
      return [year + "", Utils.getNumTwoBit(month), Utils.getMonthDays(String(year), String(month)) + ""];
    };
    const getDaysStatus = (days, type, dateInfo) => {
      let { year, month } = dateInfo;
      if (type == "prev" && days >= 7) {
        days -= 7;
      }
      return Array.from(Array(days), (v, k) => {
        return {
          day: k + 1,
          type,
          year,
          month
        };
      });
    };
    const getPreDaysStatus = (days, type, dateInfo, preCurrMonthDays) => {
      days = days - props.firstDayOfWeek;
      let { year, month } = dateInfo;
      if (type == "prev" && days >= 7) {
        days -= 7;
      }
      let months2 = Array.from(Array(preCurrMonthDays), (v, k) => {
        return {
          day: k + 1,
          type,
          year,
          month
        };
      });
      return months2.slice(preCurrMonthDays - days);
    };
    const getMonth = (curData, type) => {
      const preMonthDays = Utils.getMonthPreDay(+curData[0], +curData[1]);
      let preMonth = Number(curData[1]) - 1;
      let preYear = Number(curData[0]);
      if (preMonth <= 0) {
        preMonth = 12;
        preYear += 1;
      }
      const currMonthDays = Utils.getMonthDays(String(curData[0]), String(curData[1]));
      const preCurrMonthDays = Utils.getMonthDays(preYear + "", preMonth + "");
      const title = {
        year: curData[0],
        month: curData[1]
      };
      const monthInfo = {
        curData,
        title: translate("monthTitle", title.year, title.month),
        monthData: [
          ...getPreDaysStatus(
            preMonthDays,
            "prev",
            { month: preMonth + "", year: preYear + "" },
            preCurrMonthDays
          ),
          ...getDaysStatus(currMonthDays, "curr", title)
        ],
        cssHeight: 0,
        cssScrollHeight: 0
      };
      monthInfo.cssHeight = 39 + (monthInfo.monthData.length > 35 ? 384 : 320);
      let cssScrollHeight = 0;
      if (state.monthsData.length > 0) {
        cssScrollHeight = state.monthsData[state.monthsData.length - 1].cssScrollHeight + state.monthsData[state.monthsData.length - 1].cssHeight;
      }
      monthInfo.cssScrollHeight = cssScrollHeight;
      if (type == "next") {
        if (!state.endData || !Utils.compareDate(
          `${state.endData[0]}-${state.endData[1]}-${Utils.getMonthDays(state.endData[0], state.endData[1])}`,
          `${curData[0]}-${curData[1]}-${curData[2]}`
        )) {
          state.monthsData.push(monthInfo);
        }
      } else {
        if (!state.startData || !Utils.compareDate(
          `${curData[0]}-${curData[1]}-${curData[2]}`,
          `${state.startData[0]}-${state.startData[1]}-01`
        )) {
          state.monthsData.unshift(monthInfo);
        } else {
          state.unLoadPrev = true;
        }
      }
    };
    const initData = () => {
      let propStartDate = props.startDate ? props.startDate : Utils.getDay(0);
      let propEndDate = props.endDate ? props.endDate : Utils.getDay(365);
      state.propStartDate = propStartDate;
      state.propEndDate = propEndDate;
      state.startData = splitDate(propStartDate);
      state.endData = splitDate(propEndDate);
      if (props.defaultValue || Array.isArray(props.defaultValue) && props.defaultValue.length > 0) {
        state.currDate = props.type != "one" ? [...props.defaultValue] : props.defaultValue;
      }
      const startDate = {
        year: Number(state.startData[0]),
        month: Number(state.startData[1])
      };
      const endDate = {
        year: Number(state.endData[0]),
        month: Number(state.endData[1])
      };
      let monthsNum = endDate.month - startDate.month;
      if (endDate.year - startDate.year > 0) {
        monthsNum = monthsNum + 12 * (endDate.year - startDate.year);
      }
      if (monthsNum <= 0) {
        monthsNum = 1;
      }
      getMonth(state.startData, "next");
      let i = 1;
      do {
        getMonth(getCurrData("next"), "next");
      } while (i++ < monthsNum);
      state.monthsNum = monthsNum;
      if (props.type == "range" && Array.isArray(state.currDate)) {
        if (state.currDate.length > 0) {
          if (propStartDate && Utils.compareDate(state.currDate[0], propStartDate)) {
            state.currDate.splice(0, 1, propStartDate);
          }
          if (propEndDate && Utils.compareDate(propEndDate, state.currDate[1])) {
            state.currDate.splice(1, 1, propEndDate);
          }
          state.defaultData = [...splitDate(state.currDate[0]), ...splitDate(state.currDate[1])];
        }
      } else if (props.type == "multiple" && Array.isArray(state.currDate)) {
        if (state.currDate.length > 0) {
          let defaultArr = [];
          let obj = {};
          state.currDate.forEach((item) => {
            if (propStartDate && !Utils.compareDate(item, propStartDate) && propEndDate && !Utils.compareDate(propEndDate, item)) {
              if (!Object.hasOwnProperty.call(obj, item)) {
                defaultArr.push(item);
                obj[item] = item;
              }
            }
          });
          state.currDate = [...defaultArr];
          state.defaultData = [...splitDate(defaultArr[0])];
        }
      } else {
        if (state.currDate) {
          if (propStartDate && Utils.compareDate(state.currDate, propStartDate)) {
            state.currDate = propStartDate;
          } else if (propEndDate && !Utils.compareDate(state.currDate, propEndDate)) {
            state.currDate = propEndDate;
          }
          state.defaultData = [...splitDate(state.currDate)];
        }
      }
      let current = 0;
      let lastCurrent = 0;
      if (state.defaultData.length > 0) {
        state.monthsData.forEach((item, index) => {
          if (item.title == translate("monthTitle", state.defaultData[0], state.defaultData[1])) {
            current = index;
          }
          if (props.type == "range") {
            if (item.title == translate("monthTitle", state.defaultData[3], state.defaultData[4])) {
              lastCurrent = index;
            }
          }
        });
      }
      setDefaultRange(monthsNum, current);
      state.currentIndex = current;
      state.yearMonthTitle = state.monthsData[state.currentIndex].title;
      if (state.defaultData.length > 0) {
        if (props.type == "range") {
          chooseDay({ day: state.defaultData[2], type: "curr" }, state.monthsData[state.currentIndex], true);
          chooseDay({ day: state.defaultData[5], type: "curr" }, state.monthsData[lastCurrent], true);
        } else if (props.type == "multiple") {
          [...state.currDate].forEach((item) => {
            let dateArr = splitDate(item);
            let current2 = state.currentIndex;
            state.monthsData.forEach((item2, index) => {
              if (item2.title == translate("monthTitle", dateArr[0], dateArr[1])) {
                current2 = index;
              }
            });
            chooseDay({ day: dateArr[2], type: "curr" }, state.monthsData[current2], true);
          });
        } else {
          chooseDay({ day: state.defaultData[2], type: "curr" }, state.monthsData[state.currentIndex], true);
        }
      }
      let lastItem = state.monthsData[state.monthsData.length - 1];
      let containerHeight = lastItem.cssHeight + lastItem.cssScrollHeight;
      requestAniFrame(() => {
        if ((months == null ? void 0 : months.value) && (monthsPanel == null ? void 0 : monthsPanel.value) && (viewArea == null ? void 0 : viewArea.value)) {
          viewHeight.value = months.value.clientHeight;
          monthsPanel.value.style.height = `${containerHeight}px`;
          initPosition();
        }
      });
      state.avgHeight = Math.floor(containerHeight / (monthsNum + 1));
    };
    const scrollToDate = (date) => {
      if (Utils.compareDate(date, state.propStartDate)) {
        date = state.propStartDate;
      } else if (!Utils.compareDate(date, state.propEndDate)) {
        date = state.propEndDate;
      }
      let dateArr = splitDate(date);
      state.monthsData.forEach((item, index) => {
        if (item.title == translate("monthTitle", dateArr[0], dateArr[1])) {
          if (months.value) {
            let distance = state.monthsData[index].cssScrollHeight - months.value.scrollTop;
            if (props.toDateAnimation) {
              let flag = 0;
              let interval = setInterval(() => {
                flag++;
                if (months.value) {
                  let offset = distance / 10;
                  months.value.scrollTop = months.value.scrollTop + offset;
                }
                if (flag >= 10) {
                  clearInterval(interval);
                  if (months.value) {
                    months.value.scrollTop = state.monthsData[index].cssScrollHeight;
                  }
                }
              }, 40);
            } else {
              months.value.scrollTop = state.monthsData[index].cssScrollHeight;
            }
          }
        }
      });
    };
    const initPosition = () => {
      if (months == null ? void 0 : months.value) {
        months.value.scrollTop = state.monthsData[state.currentIndex].cssScrollHeight;
      }
    };
    useExpose({
      scrollToDate,
      initPosition
    });
    const setDefaultRange = (monthsNum, current) => {
      if (monthsNum >= 3) {
        if (current > 0 && current < monthsNum) {
          state.defaultRange = [current - 1, current + 3];
        } else if (current == 0) {
          state.defaultRange = [current, current + 4];
        } else if (current == monthsNum) {
          state.defaultRange = [current - 2, current + 2];
        }
      } else {
        state.defaultRange = [0, monthsNum + 2];
      }
      let defaultScrollTop = state.monthsData[state.defaultRange[0]].cssScrollHeight;
      state.translateY = defaultScrollTop;
    };
    const isActive = (day, month) => {
      return props.type == "range" && day.type == "curr" && getClass(day, month) == "calendar-month-day-active";
    };
    const isStartTip = (day, month) => {
      return isActive(day, month) && isStart(getCurrDate(day, month));
    };
    const isEndTip = (day, month) => {
      if (state.currDate.length >= 2 && isEnd(getCurrDate(day, month))) {
        return isActive(day, month);
      }
      return false;
    };
    const rangeTip = () => {
      if (state.currDate.length >= 2) {
        return Utils.isEqual(state.currDate[0], state.currDate[1]);
      }
    };
    const isCurrDay = (dateInfo) => {
      const date = `${dateInfo.year}-${dateInfo.month}-${Number(dateInfo.day) < 10 ? "0" + dateInfo.day : dateInfo.day}`;
      return Utils.isEqual(date, Utils.date2Str(new Date()));
    };
    const mothsViewScroll = (e) => {
      if (state.monthsData.length <= 1) {
        return;
      }
      const currentScrollTop = e.target.scrollTop;
      let current = Math.floor(currentScrollTop / state.avgHeight);
      if (current == 0) {
        if (currentScrollTop >= state.monthsData[current + 1].cssScrollHeight) {
          current += 1;
        }
      } else if (current > 0 && current < state.monthsNum - 1) {
        if (currentScrollTop >= state.monthsData[current + 1].cssScrollHeight) {
          current += 1;
        }
        if (currentScrollTop < state.monthsData[current].cssScrollHeight) {
          current -= 1;
        }
      } else {
        const viewPosition = Math.round(currentScrollTop + viewHeight.value);
        if (viewPosition < state.monthsData[current].cssScrollHeight + state.monthsData[current].cssHeight && currentScrollTop > state.monthsData[current - 1].cssScrollHeight) {
          current -= 1;
        }
        if (current + 1 <= state.monthsNum && viewPosition >= state.monthsData[current + 1].cssScrollHeight + state.monthsData[current + 1].cssHeight) {
          current += 1;
        }
        if (current >= 1 && currentScrollTop < state.monthsData[current - 1].cssScrollHeight) {
          current -= 1;
        }
      }
      if (state.currentIndex !== current) {
        state.currentIndex = current;
        setDefaultRange(state.monthsNum, current);
      }
      state.yearMonthTitle = state.monthsData[current].title;
    };
    const resetRender = () => {
      state.chooseData.splice(0);
      state.monthsData.splice(0);
      initData();
    };
    initData();
    watch(
      () => props.defaultValue,
      (val) => {
        if (val) {
          if (props.poppable) {
            resetRender();
          }
        }
      }
    );
    return {
      weeks,
      compConthsData,
      showTopBtn,
      topInfo,
      bottomInfo,
      rangeTip,
      mothsViewScroll,
      getClass,
      isStartTip,
      isEndTip,
      chooseDay,
      isCurrDay,
      confirm,
      monthsPanel,
      months,
      weeksPanel,
      viewArea,
      ...toRefs(state),
      ...toRefs(props),
      translate
    };
  }
});
const _hoisted_1 = {
  key: 0,
  class: "calendar-title"
};
const _hoisted_2 = {
  key: 1,
  class: "calendar-top-slot"
};
const _hoisted_3 = {
  key: 2,
  class: "calendar-curr-month"
};
const _hoisted_4 = {
  class: "calendar-weeks",
  ref: "weeksPanel"
};
const _hoisted_5 = {
  class: "calendar-months-panel",
  ref: "monthsPanel"
};
const _hoisted_6 = { class: "calendar-month-title" };
const _hoisted_7 = { class: "calendar-month-con" };
const _hoisted_8 = ["onClick"];
const _hoisted_9 = { class: "calendar-day" };
const _hoisted_10 = {
  key: 0,
  class: "calendar-curr-tips calendar-curr-tips-top"
};
const _hoisted_11 = {
  key: 1,
  class: "calendar-curr-tips calendar-curr-tips-bottom"
};
const _hoisted_12 = {
  key: 2,
  class: "calendar-curr-tip-curr"
};
const _hoisted_13 = {
  key: 4,
  class: "calendar-day-tip"
};
const _hoisted_14 = {
  key: 0,
  class: "nut-calendar-footer"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(["nut-calendar nut-calendar-taro", {
      "nut-calendar-tile": !_ctx.poppable,
      "nut-calendar-nofooter": _ctx.isAutoBackFill
    }])
  }, [
    createElementVNode("view", {
      class: normalizeClass(["nut-calendar-header", { "nut-calendar-header-tile": !_ctx.poppable }])
    }, [
      _ctx.showTitle ? (openBlock(), createElementBlock("view", _hoisted_1, toDisplayString(_ctx.title || _ctx.translate("title")), 1)) : createCommentVNode("", true),
      _ctx.showTopBtn ? (openBlock(), createElementBlock("view", _hoisted_2, [
        renderSlot(_ctx.$slots, "btn")
      ])) : createCommentVNode("", true),
      _ctx.showSubTitle ? (openBlock(), createElementBlock("view", _hoisted_3, toDisplayString(_ctx.yearMonthTitle), 1)) : createCommentVNode("", true),
      createElementVNode("view", _hoisted_4, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.weeks, (item, index) => {
          return openBlock(), createElementBlock("view", {
            class: "calendar-week-item",
            key: index
          }, toDisplayString(item), 1);
        }), 128))
      ], 512)
    ], 2),
    createElementVNode("view", {
      class: "nut-calendar-content",
      ref: "months",
      onScroll: _cache[0] || (_cache[0] = (...args) => _ctx.mothsViewScroll && _ctx.mothsViewScroll(...args))
    }, [
      createElementVNode("view", _hoisted_5, [
        createElementVNode("view", {
          class: "viewArea",
          ref: "viewArea",
          style: normalizeStyle({ transform: `translateY(${_ctx.translateY}px)` })
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.compConthsData, (month, index) => {
            return openBlock(), createElementBlock("view", {
              class: "calendar-month",
              key: index
            }, [
              createElementVNode("view", _hoisted_6, toDisplayString(month.title), 1),
              createElementVNode("view", _hoisted_7, [
                createElementVNode("view", {
                  class: normalizeClass(["calendar-month-item", _ctx.type === "range" ? "month-item-range" : ""])
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(month.monthData, (day, i) => {
                    return openBlock(), createElementBlock("view", {
                      key: i,
                      class: normalizeClass(["calendar-month-day", _ctx.getClass(day, month)]),
                      onClick: ($event) => _ctx.chooseDay(day, month)
                    }, [
                      createElementVNode("view", _hoisted_9, [
                        renderSlot(_ctx.$slots, "day", {
                          date: day.type == "curr" ? day : ""
                        }, () => [
                          createTextVNode(toDisplayString(day.type == "curr" ? day.day : ""), 1)
                        ])
                      ]),
                      _ctx.topInfo ? (openBlock(), createElementBlock("view", _hoisted_10, [
                        renderSlot(_ctx.$slots, "topInfo", {
                          date: day.type == "curr" ? day : ""
                        })
                      ])) : createCommentVNode("", true),
                      _ctx.bottomInfo ? (openBlock(), createElementBlock("view", _hoisted_11, [
                        renderSlot(_ctx.$slots, "bottomInfo", {
                          date: day.type == "curr" ? day : ""
                        })
                      ])) : createCommentVNode("", true),
                      !_ctx.bottomInfo && _ctx.showToday && _ctx.isCurrDay(day) ? (openBlock(), createElementBlock("view", _hoisted_12, toDisplayString(_ctx.translate("today")), 1)) : createCommentVNode("", true),
                      _ctx.isStartTip(day, month) ? (openBlock(), createElementBlock("view", {
                        key: 3,
                        class: normalizeClass(["calendar-day-tip", { "calendar-curr-tips-top": _ctx.rangeTip() }])
                      }, toDisplayString(_ctx.startText || _ctx.translate("start")), 3)) : createCommentVNode("", true),
                      _ctx.isEndTip(day, month) ? (openBlock(), createElementBlock("view", _hoisted_13, toDisplayString(_ctx.endText || _ctx.translate("end")), 1)) : createCommentVNode("", true)
                    ], 10, _hoisted_8);
                  }), 128))
                ], 2)
              ])
            ]);
          }), 128))
        ], 4)
      ], 512)
    ], 544),
    _ctx.poppable && !_ctx.isAutoBackFill ? (openBlock(), createElementBlock("view", _hoisted_14, [
      createElementVNode("view", {
        class: "calendar-confirm-btn",
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.confirm && _ctx.confirm(...args))
      }, toDisplayString(_ctx.confirmText || _ctx.translate("confirm")), 1)
    ])) : createCommentVNode("", true)
  ], 2);
}
var CalendarItem = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { CalendarItem as C, Utils as U };
